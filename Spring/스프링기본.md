# 🌸스프링 기초🌸

## 스프링 부트

---

- 스프링을 간편하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 라이브러리 최적화도 알아서 해줌

## 스프링 핵심

---

- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - **객체 지향 언어**
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 **좋은 객체 지향** 애플리케이션을 개발할 수 있게 도와주는 프레임워크

## 객체 지향 프로그래밍

---

- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 **“객체”**들의 **모임**으로 파악하고자 하는 것이다. 각각의 **객체**는 **메시지**를 주고받고, 데이터를 처리할 수 있다. (**협력**)
- 객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경**이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.
- 유연하고, 변경이 용이? → **다형성(Polymorphism)**
  - 레고 블럭 조립하듯이
  - 키보드, 마우스 갈아 끼우듯이
  - 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법
- 다형성은 세상을 **`역할과 구현`**으로 구분
  - ex) 자동차 → 자동차가 바뀌어도 운전하는 방법은 변하지 않는다. 즉 사람은 자동차의 역할에만 의존하고 있음. 구현은 각 제조사가 각자의 방법으로 함
  - ex) 공연 → 로미오와 줄리엣 공연을 한다고 하면 각 등장인물 역할을 다른 배우들로 교체할 수 있다.
- 즉 클라이언트는 내부 구조를 몰라도 되고 신경쓰지 않아도 된다.(ex)내연기관 자동차가 전기자동차로 바뀌어도 운전 방법은 똑같다.)
- 다형성의 본질
  - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
  - 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
- 다형성의 한계
  - 역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생한다.
  - 자동차를 비행기로 변경한다면?
  - 대본 자체가 변경된다면?
  - USB 인터페이스가 변경된다면?
  - 인터페이스를 안정적으로 잘 설계하는 것이 중요

## 좋은 객체 지향 설계의 5가지 원칙 (**SOLID**)

---

- SRP(Single Responsibility principle) → 단일 책임 원칙
  - 한 클래스는 하나의 책임만 가져야 한다.
  - 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것
  - ex) UI 변경, 객체의 생성과 사용을 분리
  - 책임의 크기를 적절히 잘 조절해야 함
- **OCP(Open / closed principle) → 개방 폐쇄의 원칙**
  - 소프트웨어 요소는 확장에는 열러있으나, 변경에는 닫혀 있어야 한다.
  - 다형성을 활용해서 기능의 확장은 하지만, 해당 기능을 변경하면 안된다.
  - 하지만 DB를 바꿀때와 같은 경우는 client쪽의 코드의 일부 수정이 불가피하다. 이 때는 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
- LSP(Liskov substitution principle) → 리스코프 치환 원칙
  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
  - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙
  - ex) 자동차 인터페이스의 악셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP위반, 느리더라도 앞으로 가야함
- ISP(Interface Segregation principle) → 인터페이스 분리 원칙
  - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
  - 자동차 인터페이스 → 운전 인터패이스, 정비 인터페이스로 분리
  - 사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리
- **DIP(Dependency inversion principle) → 의존성 역전 법칙**
  - 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”
  - 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 한다.

## 스프링의 DI(Dependency Injection)

---

- 스프링에서는 DI를 통해 다형성 + OCP, DIP를 가능하게 한다.
- 클라이언트의 코드 변경 없이 기능 확장이 가능하다.
- AppConfig를 통해 구현 객체를 생성하고 연결하는 일을 해준다.

## IOC(Inversion of Control) → 제어의 역전

---

- 기존에는 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.
- 하지만 AppConfig 사용 후에는 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 즉 제어 흐름은 AppConfig가 가져간다.
- 프로젝트의 AppConfig와 같이 객체를 생성하고 관리하며 의존관계를 연결해주는 역할을 하는 것을 **DI 컨테이너**라고 한다.

## 스프링 컨테이너

---

- 스프링을 사용하면서 `Appconfig` 가 했던 일을 스프링 컨테이너를 통해 할 수 있다.
- 스프링 컨테이너는 `@Configuration`이 붙은 `AppConfig`를 설정 정보로 사용한다. 여기서 `@Bean` 이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.
- 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.
- `Bean` 의 이름은 기본적으로 메서드 이름과 동일하고, name속성을 통해 사용자화 할 수 있다.

## 스프링 컨테이너와 스프링 빈

---

- `ApplicationContext`를 스프링 컨테이너라 한다.
- `ApplicationContext`는 인터페이스이다.
- 스프링 컨테이너는 XML을 기반으로 만들 수 있고, 에노테이션 기반의 자바 설정 클래스로 만들 수 있다.
- 자바 설정 클래스 기반의 스프링컨테이너를 만들려면 `new AnnotationConfigApplication(AppConfig.class);` 를 사용하면 된다.
- 이 클래스는 `ApplicationContext`의 구현체이다.
- ⚠️주의 → Bean 이름은 항상 다른 이름을 부여해야 한다. 같은 이름을 부여하면 기존 빈을 덮어버리거나 설정에 따라 오류가 발생한다.
- `Bean`을 검색할 때는 상속 받은 클래스 component가 있을 때 모두 불러온다.

## 싱글톤 컨테이너

---

- 싱글톤: 객체를 1개만 생성해서 클라이언트끼리 공유하는 것
- 스프링 컨테이너가 객체 인스턴스를 기본적으로 싱글톤으로 관리한다.

## 싱글톤 방식의 주의점

---

- 무상태(stateless)로 설계해야 한다.
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 가급적 읽기만 가능해야한다.

## 컴포넌트 스캔과 의존관계 자동 주입

---

- 개발자가 일일히 `@Bean`을 입력하는 것은 힘든 일
- 그래서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
- AutoAppConfig에 `@Configuration` 과 `@CoponentScan`을 입력하고 클래스는 구현하지 않은 채로 다른 구현 클래스 들에 `@Component` 를 입력하고, 생성자에 `@Autowired` 를 입력하면 Spring이 생성자에 사용한 interface에 맞는 맞는 구현체를 자동으로 연결해준다.
- `@ComponentScan` annotation에 ‘basePackages’ 옵션을 통해 탐색할 베이스 패키지를 지정할 수 있다. (베이스 패키지 부터 하위패키지 전부를 탐색한다.) (지정하지 않으면 파일이 위치한 패키지가 base 패키지가 된다.)
- 컴포넌트 스캔은 `@Component` 뿐만 아니라 다음과 내용도 추가로 대상에 포함된다.
  - `@Component` : 컴포넌트 스캔에 활용
  - `@Controler` : 스프링 MVC 컨트롤러에 활용
  - `@Service` : 스프링 비즈니스 로직에서 사용
  - `@Repository` : 스프링 데이터 접근 계층에서 사용
  - `@Configuration` : 스프링 설정 정보에서 사용

## 컴포넌트 중복 등록과 충돌

---

- 컴포넌트 이름을 지정하지 않을 경우 자동으로 등록이 된다.(클래스명으로(단, 첫글자는 소문자로))
- 하지만 다른 컴포넌트에 이름을 붙였는데 우연히 자동으로 등록됐던 컴포넌트와 일치한다면, 해당 컴포넌트를 오버라이딩 해버려서 자동 등록된 컴포넌트를 사용할 수 없는 현상이 생긴다.
- 이를 방지하기 위해 최신 스프링부트에서는 수동으로 등록한 컴포넌트가 자동 등록 컴포넌트와 겹치면 에러가 발생한다.

## 의존관계 주입 방법

---

- 생성자 주입
  - 생성자를 통해 인스턴스 생성시 구현체 지정
  - 생성자가 클래스에 단 1개이면 `@Autowired`를 생략할 수 있다.
- 수정자 주입(setter 주입)
  - setter 함수를 만든 뒤에 `@Autowired` 를 입력하면 의존성 주입이 자동으로 된다.
  - **선택, 변경** 가능성이 있는 의존관계에 사용한다.
    - `@Autowired(required = false)` 를 통해 선택성을 부여할 수 있다.
- 필드 주입
  - 변수를 선언할 때 앞에 Autowired를 붙여준다.
  - 사용하기 간단하다는 장점이 있지만, 컴포넌트간 순환참조가 발생할 수 있고, 테스트가 어려워서 사용하지 않는다.(스프링 컨테이너가 아닌 순수 자바 코드로는 테스트를 진행할 수 없다.)❌
- 일반 메서드 주입

  - 이름만 setter가 아닌 다른 메서드로 만들고 똑같이 Autowired를 붙이는 방식

- Spring에서는 `Bean` 등록을 먼저 한 다음에 호출을 통해 의존관계 주입을 한다. `@Autowired`로 된 정보를 바탕으로 Spring이 알아서 의존관계 주입을 한다.
- 하지만 생성자 주입의 경우 클래스 인스턴스를 가져올 때 생성자가 바로 호출되므로 빈 등록과 의존관계 주입이 동시에 일어난다.

## 의존관계 옵션

---

- Autowired 옵션으로 requried=false를 넣으면 의존성 주입을 할 객체가 스프링 빈으로 등록되지 않아있을 때 호출하지 않는다.

## 생성자 주입을 선택해야 하는 이유

---

- 테스트가 용이하다. (수정자 주입의 경우 setter를 한번 더 호출해야 한다.)
- 필드의 type을 final로 지정할 수 있어서, 생성자 호출 이후 필드값이 변경되지 않음을 보장할 수 있다.

## 롬복

---

- 생성자 주입을 더 간편하게 해주는 plugin (최신 인텔리제이에서는 기본 설치돼있음)
- 사용하려면 설정의 `Annotation Processors` 를 켜줘야 함
- 롬복을 사용하면 Getter, Setter코드를 안만들어도 자동으로 생성해줌(사용방법: `@Getter` `@Setter` 를 클래스 앞에 붙이기)
- `@RequiredArgsConstructor`를 통해 final이 붙은 필드의 생성자를 자동으로 생성해줌
- 최근에는 생성자를 딱 1개 두고, `@AutoWired`를 생략하는 방법을 주로 사용한다. 여기에 Lombok 라이브러리의 `@RequriedArgsConstructor`를 함께 사용하면 기능은 다 제공하면서, 코드는 깔끔하게 사용할 수 있다.

## 스프링 빈 중복등록

---

- 한개의 interface에 2개 이상의 구현체가 있고, 이것들을 다 component로 등록해놓으면 `NoUniqueBeanDefinitionException` 오류가 발생한다.

## 중복 빈의 충돌 방지법

---

- `@Autowired` 를 붙이면 구현체가 여러개 있을 때 변수명이 하나의 구현체와 일치한다면 해당 구현체로 의존성 주입을 해줌
- `@Qualifier` 를 통해서 구현체에 이름을 지정하고, 의존성 주입이 발생한는 변수 앞에 같은 Annotation을 써주면 해당 구현체가 의존성주입됨
- `@Primary` 를 통해서 구현체에 우선순위를 부여할 수 있음
- Qualifier와 Primary가 동시에 있다면, Qualifier가 우선순위가 높다. (Spring은 상세히 동작하는 것(좁은 범위의 선택권)에 우선권을 준다.)

## 사용자정의 Annotation 만들기

---

- `@Qualifier` 빈을 사용할 때 name에 오타가 있어도 오류가 나지 않아 버그를 잡기 어려울 때 가 있음
- 이 때 사용자 정의 어노테이션을 생성해서 사용하면 버그를 막을 수 있다.
- Annotation은 상속이 안된다. 재정의할 수 있다.

## 여러 구현체 BEAN 모두 등록하기

---

- Map이나 List로 구현체를 받아오도록 하면 해당 클래스에 맞는 구현체들을 Spring이 알아서 연결해준다.

## 자동, 수동의 올바른 실무 운영 기준

---

- 현재는 갈수록 자동 의존관계 주입을 선호하는 추세
- `@Component` 뿐만 아니라 `@Controller` `@Service` `@Repository` 처럼 계층에 맞추어 일반적인 애플리케이션 로직을 자동으로 스캔할 수 있도록 지원한다.
- `업무 로직 빈` 을 사용할 때 자동 설정을 적극 활요앟ㄴ다,
- `기술 지원 빈` 을 사용할 때 수동빈을 사용하면 좋다. (오류를 찾기 힘들고, 광범위하게 영향을 미친다, Bean간의 관계가 명확하지 않다.)

## 빈 생명주기 콜백

---

- 빈이 생기고 사라질 때, 혹은 특정 상황에서 호출되는 메서드
- Bean은 객체 생성 → 의존관계 주입의 과정을 거치는데, 빈에게 콜백 메서드를 줘서 의존관계 주입 직후 할 일을 줄 수 있다.
- 그러면 생성자에다가 할일을 다 주면 되지 않나요❓
  - 객체가 생기면서 서버연결과 같은 무거운 작업을 수행한다면 객체 생성시 너무 많은 시간이 걸린다.
  - 따라서 콜백 메서드를 적절히 활용해서 객체를 먼저 만든 다음에 콜백 메서드를 통해 나머지 무거운 할일을 주는 것이 더 좋다.

## 콜백함수 사용하는 3가지 방법 - 1. 인터페이스

---

- `InitializeBean` 인터페이스
  - `afterPropertiesSet` 메서드를 통해 의존관계 주입 완료 후 할 작업을 지정할 수 있다.
- `DisposableBean`
  - `destroy` 메서드를 통해 소멸되기 전 작업을 지정할 수 있다.
- 이 방법의 단점
  1. 코드가 스프링 전용 인터페이스에 의존한다.
  2. 초기화, 소멸 메서드의 이름을 변경할 수 없다.
  3. 내가 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.
- 따라서 현재는 거의 사용❎

## 콜백함수 사용하는 3가지 방법 - 2. 설정 정보에 초기화 메서드, 종료 메서드 지정

---

- `@Bean` annotation의 속성으로 `initmethod` 와 `destroyMethod` 를 지정할 수 있다.
- 특징
  - 메서드 이름을 자유롭게 할 수 있다.
  - 스프링 빈이 스프링 코드에 의존하지 않는다.
  - 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.
- 종료메서드 추론
  - `@Bean` 에는 destroymethod를 자신이 추론해서 적용해 주는 기능이 있다.(infer)
  - close나 destroy라는 이름을 가진 메서드가 있으면 알아서 호출하고 끝낸다.

## 콜백함수 사용하는 3가지 방법 - 3. 빈 등록 초기화, 소멸 메서드

---

- 결론적으로 스프링에서 제일 많이 사용
- 메서드 위에 Annotation을 직접 붙임
- `@PostConstruct` `@PreDestroy` 사용함
- 해당 기능은 Spring이 아니라 자바에서 지원하는 것 (`javax`에 정의돼있음)
- 단점은 외부 라이브러리에 적용할 수 없다는 것이다. → 이 기능을 사용하려면 2번째 방법을 활용하자

## 빈 스코프

---

- 빈 스코프: 빈이 존재할 수 있는 범위
- 빈 스코프 종류
  - 싱글톤 : 스프링 컨테이너 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
  - 프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
  - 웹 관련 스코프
    - request : 웹 요청이 들어오고 나갈때까지 유지되는 스코프
    - session : 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
    - application : 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프

## 프로토타입 빈

---

- 싱글톤 bean은 여러 유저의 요청을 한 instance가 처리한다.
- 프로토타입의 경우는 요청마다 새로운 Bean을 생성하고 DI를 해준다. 이후 사용자한테 그 객체를 반환하고 **스프링은 더이상 그 객체를 관리해주지 않는다.**
- 따라서 이후에 predestory 같은 스프링의 메서드가 호출되지 않는다‼
- 싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드가 실행 되지만, 프로토타입 스코프 빈은 스프링 컨테이너에서 빈을 조회할 때 생성되고, 초기화 메서드가 실행된다.

## 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 주의점

---

- 싱글톤 빈 안에서 프로토타입 빈을 사용할 때
  - 싱글톤이 생성되면서 의존관계 자동주입에 의해 프로토타입 빈이 생성되고
  - 이후 싱글톤 빈을 이용해 프로토타입 빈을 사용할 때 의도치 않게 빈이 매번 생성되지 않는다.

## 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결

---

- `Dependency Lookup` : 의존관계를 외부에서 주입(DI)받는 것이 아니라 직접 찾는 것
- 싱글톤 안에 `ApplicationContext` 를 넣어서 로직 호출 시 매번 프로토타입 빈을 생성해줄 수도 있지만, 이렇게 하면 Spring문맥에 너무 의존하게 된다.
- `ObjectProvier` 를 통해 DL을 할 수 있다. → 하지만 역시 Spring에 의존
- `JSR-330 Provider`를 사용하면 Spring에 의존하지 않고 사용할 수 있다. (하지만 Gradle에 라이브러리를 추가해야한다.)

## 웹 스코프

---

- `request` : HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 BEAN 인스턴스가 생성되고 관리된다.
- `session` : HTTP Session과 동일한 생명주기를 가지는 스코프
- `application` : 서블릿 컨텍스트(`ServletContext` )와 동일한 생명주기를 가지는 스코프
- `websocket` : 웹 소켓과 동일한 생명주기를 가지는 스코프
