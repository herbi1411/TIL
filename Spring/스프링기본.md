# 🌸스프링 기초🌸

## 스프링 부트

---

- 스프링을 간편하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 라이브러리 최적화도 알아서 해줌

## 스프링 핵심

---

- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - **객체 지향 언어**
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 **좋은 객체 지향** 애플리케이션을 개발할 수 있게 도와주는 프레임워크

## 객체 지향 프로그래밍

---

- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 **“객체”**들의 **모임**으로 파악하고자 하는 것이다. 각각의 **객체**는 **메시지**를 주고받고, 데이터를 처리할 수 있다. (**협력**)
- 객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경**이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.
- 유연하고, 변경이 용이? → **다형성(Polymorphism)**
    - 레고 블럭 조립하듯이
    - 키보드, 마우스 갈아 끼우듯이
    - 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법
- 다형성은 세상을 **`역할과 구현`**으로 구분
    - ex) 자동차 → 자동차가 바뀌어도 운전하는 방법은 변하지 않는다. 즉 사람은 자동차의 역할에만 의존하고 있음. 구현은 각 제조사가 각자의 방법으로 함
    - ex) 공연 → 로미오와 줄리엣 공연을 한다고 하면 각 등장인물 역할을 다른 배우들로 교체할 수 있다.
- 즉 클라이언트는 내부 구조를 몰라도 되고 신경쓰지 않아도 된다.(ex)내연기관 자동차가 전기자동차로 바뀌어도 운전 방법은 똑같다.)
- 다형성의 본질
    - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
    - 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
- 다형성의 한계
    - 역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생한다.
    - 자동차를 비행기로 변경한다면?
    - 대본 자체가 변경된다면?
    - USB 인터페이스가 변경된다면?
    - 인터페이스를 안정적으로 잘 설계하는 것이 중요
    

## 좋은 객체 지향 설계의 5가지 원칙 (**SOLID**)

---

- SRP(Single Responsibility principle) → 단일 책임 원칙
    - 한 클래스는 하나의 책임만 가져야 한다.
    - 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것
    - ex) UI 변경, 객체의 생성과 사용을 분리
    - 책임의 크기를 적절히 잘 조절해야 함
- **OCP(Open / closed principle) → 개방 폐쇄의 원칙**
    - 소프트웨어 요소는 확장에는 열러있으나, 변경에는 닫혀 있어야 한다.
    - 다형성을 활용해서 기능의 확장은 하지만, 해당 기능을 변경하면 안된다.
    - 하지만 DB를 바꿀때와 같은 경우는 client쪽의 코드의 일부 수정이 불가피하다. 이 때는 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
- LSP(Liskov substitution principle) → 리스코프 치환 원칙
    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
    - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙
    - ex) 자동차 인터페이스의 악셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP위반, 느리더라도 앞으로 가야함
- ISP(Interface Segregation principle) → 인터페이스 분리 원칙
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - 자동차 인터페이스 → 운전 인터패이스, 정비 인터페이스로 분리
    - 사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리
- **DIP(Dependency inversion principle) → 의존성 역전 법칙**
    - 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”
    - 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 한다.

## 스프링의 DI(Dependency Injection)

---

- 스프링에서는 DI를 통해 다형성 + OCP, DIP를 가능하게 한다.
- 클라이언트의 코드 변경 없이 기능 확장이 가능하다.
- AppConfig를 통해 구현 객체를 생성하고 연결하는 일을 해준다.

## IOC(Inversion of Control) → 제어의 역전

---

- 기존에는 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.
- 하지만 AppConfig 사용 후에는 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 즉 제어 흐름은 AppConfig가 가져간다.
- 프로젝트의 AppConfig와 같이 객체를 생성하고 관리하며 의존관계를 연결해주는 역할을 하는 것을 **DI 컨테이너**라고 한다.

## 스프링 컨테이너

---

- 스프링을 사용하면서 `Appconfig` 가 했던 일을 스프링 컨테이너를 통해 할 수 있다.
- 스프링 컨테이너는 `@Configuration`이 붙은 `AppConfig`를 설정 정보로 사용한다. 여기서 `@Bean` 이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.
- 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.
- `Bean` 의 이름은 기본적으로 메서드 이름과 동일하고, name속성을 통해 사용자화 할 수 있다.

## 스프링 컨테이너와 스프링 빈

---

- `ApplicationContext`를 스프링 컨테이너라 한다.
- `ApplicationContext`는 인터페이스이다.
- 스프링 컨테이너는 XML을 기반으로 만들 수 있고, 에노테이션 기반의 자바 설정 클래스로 만들 수 있다.
- 자바 설정 클래스 기반의 스프링컨테이너를 만들려면 `new AnnotationConfigApplication(AppConfig.class);` 를 사용하면 된다.
- 이 클래스는 `ApplicationContext`의 구현체이다.
- ⚠️주의 → Bean 이름은 항상 다른 이름을 부여해야 한다. 같은 이름을 부여하면 기존 빈을 덮어버리거나 설정에 따라 오류가 발생한다.
- `Bean`을 검색할 때는 상속 받은 클래스 component가 있을 때 모두 불러온다.

## 싱글톤 컨테이너

---

- 싱글톤: 객체를 1개만 생성해서 클라이언트끼리 공유하는 것
- 스프링 컨테이너가 객체 인스턴스를 기본적으로 싱글톤으로 관리한다.

## 싱글톤 방식의 주의점

---

- 무상태(stateless)로 설계해야 한다.
    - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
    - 가급적 읽기만 가능해야한다.

## 컴포넌트 스캔과 의존관계 자동 주입

---

- 개발자가 일일히 `@Bean`을 입력하는 것은 힘든 일
- 그래서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
- AutoAppConfig에 `@Configuration` 과 `@CoponentScan`을 입력하고 클래스는 구현하지 않은 채로 다른 구현 클래스 들에 `@Component` 를 입력하고, 생성자에 `@Autowired` 를 입력하면 Spring이 생성자에 사용한 interface에 맞는 맞는 구현체를 자동으로 연결해준다.
- `@ComponentScan` annotation에 ‘basePackages’ 옵션을 통해 탐색할 베이스 패키지를 지정할 수 있다. (베이스 패키지 부터 하위패키지 전부를 탐색한다.) (지정하지 않으면 파일이 위치한 패키지가 base 패키지가 된다.)
- 컴포넌트 스캔은 `@Component` 뿐만 아니라 다음과 내용도 추가로 대상에 포함된다.
    - `@Component` : 컴포넌트 스캔에 활용
    - `@Controler` : 스프링 MVC 컨트롤러에 활용
    - `@Service` : 스프링 비즈니스 로직에서 사용
    - `@Repository` : 스프링 데이터 접근 계층에서 사용
    - `@Configuration` : 스프링 설정 정보에서 사용

## 컴포넌트 중복 등록과 충돌

---

- 컴포넌트 이름을 지정하지 않을 경우 자동으로 등록이 된다.(클래스명으로(단, 첫글자는 소문자로))
- 하지만 다른 컴포넌트에 이름을 붙였는데 우연히 자동으로 등록됐던 컴포넌트와 일치한다면, 해당 컴포넌트를 오버라이딩 해버려서 자동 등록된 컴포넌트를 사용할 수 없는 현상이 생긴다.
- 이를 방지하기 위해 최신 스프링부트에서는 수동으로 등록한 컴포넌트가 자동 등록 컴포넌트와 겹치면 에러가 발생한다.

## 의존관계 주입 방법

---

- 생성자 주입
    - 생성자를 통해 인스턴스 생성시 구현체 지정
    - 생성자가 클래스에 단 1개이면 `@Autowired`를 생략할 수 있다.
- 수정자 주입(setter 주입)
    - setter 함수를 만든 뒤에 `@Autowired` 를 입력하면 의존성 주입이 자동으로 된다.
    - **선택, 변경** 가능성이 있는 의존관계에 사용한다.
        - `@Autowired(required = false)` 를 통해 선택성을 부여할 수 있다.
- 필드 주입
    - 변수를 선언할 때 앞에 Autowired를 붙여준다.
    - 사용하기 간단하다는 장점이 있지만, 컴포넌트간 순환참조가 발생할 수 있고, 테스트가 어려워서 사용하지 않는다.(스프링 컨테이너가 아닌 순수 자바 코드로는 테스트를 진행할 수 없다.)❌
- 일반 메서드 주입
    - 이름만 setter가 아닌 다른 메서드로 만들고 똑같이 Autowired를 붙이는 방식

- Spring에서는  `Bean` 등록을 먼저 한 다음에 호출을 통해 의존관계 주입을 한다. `@Autowired`로 된 정보를 바탕으로 Spring이 알아서 의존관계 주입을 한다.
- 하지만 생성자 주입의 경우 클래스 인스턴스를 가져올 때  생성자가 바로 호출되므로 빈 등록과 의존관계 주입이 동시에 일어난다.

## 의존관계 옵션

---

- Autowired 옵션으로 requried=false를 넣으면 의존성 주입을 할 객체가 스프링 빈으로 등록되지 않아있을 때 호출하지 않는다.

## 생성자 주입을 선택해야 하는 이유

---

- 테스트가 용이하다. (수정자 주입의 경우 setter를 한번 더 호출해야 한다.)
- 필드의 type을 final로 지정할 수 있어서, 생성자 호출 이후 필드값이 변경되지 않음을 보장할 수 있다.

## 롬복

---

- 생성자 주입을 더 간편하게 해주는 plugin (최신 인텔리제이에서는 기본 설치돼있음)
- 사용하려면 설정의 `Annotation Processors` 를 켜줘야 함
- 롬복을 사용하면 Getter, Setter코드를 안만들어도 자동으로 생성해줌(사용방법: `@Getter` `@Setter` 를 클래스  앞에 붙이기)
- `@RequiredArgsConstructor`를 통해 final이 붙은 필드의 생성자를 자동으로 생성해줌
- 최근에는 생성자를 딱 1개 두고, `@AutoWired`를 생략하는 방법을 주로 사용한다. 여기에 Lombok 라이브러리의 `@RequriedArgsConstructor`를 함께 사용하면 기능은 다 제공하면서, 코드는 깔끔하게 사용할 수 있다.

## 스프링 빈 중복등록

---

- 한개의 interface에 2개 이상의 구현체가 있고, 이것들을 다 component로 등록해놓으면 `NoUniqueBeanDefinitionException` 오류가 발생한다.

## 중복 빈의 충돌 방지법

---

- `@Autowired` 를 붙이면 구현체가 여러개 있을 때 변수명이 하나의 구현체와 일치한다면 해당 구현체로 의존성 주입을 해줌
- `@Qualifier` 를 통해서 구현체에 이름을 지정하고, 의존성 주입이 발생한는 변수 앞에 같은 Annotation을 써주면 해당 구현체가 의존성주입됨
- `@Primary` 를 통해서 구현체에 우선순위를 부여할 수 있음
- Qualifier와 Primary가 동시에 있다면, Qualifier가 우선순위가 높다. (Spring은 상세히 동작하는 것(좁은 범위의 선택권)에 우선권을 준다.)